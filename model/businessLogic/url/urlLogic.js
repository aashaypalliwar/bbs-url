const URL = require('../../dbModel/urlModel');
const AppError = require('../../../utils/appError');
const validateSuborgUrlUpdate = require('./urlUtils').validateSuborgUrlUpdate;
const dnsCheck = require('./urlUtils').dnsCheck;
const generateEndpoint = require('./urlUtils').generateEndpoint;

// Get all the URLs
const getAllURLs = async (next) => {
    try {
        let urlList = await URL.find().lean();
        if(!urlList)
            return next(new AppError("Something went wrong.", 500));
        return urlList;
    }
    catch(err){
        next(err);
    }
};

// Get all URLs generated by a given user
const getURLsByUser = async (user, next) => {
    try {
        let urlList = await URL.find({userID: user._id}).lean();
        if(!urlList)
            return next(new AppError("No user found with the given ID", 404));
        return urlList;
    }
    catch(err){
        next(err);
    }
};

// Blacklist a URL
const blacklistURL = async (id, next) => {
    try{
        let updatedInfo = await URL.findByIdAndUpdate(id, {
           blacklisted: true
        }, {new : true});
        if(!updatedInfo)
            return next(new AppError("Failed to update. Please try again", 500));
        return updatedInfo;
    }
    catch (err) {
        next(err);
    }
}

// Whitelist a URL
const whitelistURL = async (id, next) => {
    try{
        let updatedInfo = await URL.findByIdAndUpdate(id, {
            blacklisted: false
        }, {new : true});
        if(!updatedInfo)
            return next(new AppError("Failed to update. Please try again", 500));
        return updatedInfo;
    }
    catch (err) {
        next(err);
    }
}

//Delete url
const deleteURL = async (id, userID, next) => {
    try{
        let deletedURL = await URL.deleteOne({ _id: id, userID: userID});
        if(!deletedURL)
            return next(new AppError("Failed to delete. Please try again", 500));
        console.log(`deleted url with id : ${id}`);
        return deletedURL;
    }
    catch(err){
        next(err);
    }
}

// Get redirect URL
const getRedirectURL = async (endpoint, next) => {
    try {
        let urlData = await URL.findOne({shortURLEndPoint: endpoint, blacklisted : false}).lean();
        if(!urlData)
            return next(new AppError("The short URL does not redirect to a valid location.", 404));
        return urlData.originalURL;
    }
    catch(err){
        next(err);
    }
}

//Increment hits on URL
const incrementURLHits = async (shortURL, next) => {
    try{
        let updatedURLInfo = await URL.findOneAndUpdate(
            { shortURLEndPoint: shortURL},
            { $inc: { hits: 1 }  },
            {new: true, useFindAndModify: false});
        if(!updatedURLInfo)
            return next(new AppError("Failed to update. Please try again", 500));
        return updatedURLInfo;
    }
    catch(err){
        next(err);
    }
};

//Update custom URL (sub-organization)
const updateSuborgURL = async (url, newEndpoint, next) => {
    try{
        let isValid = validateSuborgUrlUpdate(url.suborg, newEndpoint);
        if(isValid){
            let updatedURLInfo = await URL.findOneAndUpdate(
                { _id: url._id},
                { shortURLEndPoint: newEndpoint },
                {new: true});
            if(!updatedURLInfo)
                return next(new AppError("Failed to update. Please try again", 500));
            return updatedURLInfo;
        }
    }
    catch(err){
        next(err);
    }
}

//Create a new short URL
const createNewShortURL = async (urlInfo, next) => {
    try{
        //throw error
        let isValid = await dnsCheck(urlInfo.originalURL);
        if(!isValid){
            return next(new AppError("Original URL doesn't exist", 400));
        }
        if(!urlInfo.originalURL.startsWith('https://') && !urlInfo.originalURL.startsWith('http://'))
            urlInfo.originalURL = 'https://'+urlInfo.originalURL;


         let shortURLEndPoint = await generateEndpoint();

        let newURL = new URL(
            {
                email: urlInfo.email,
                name: urlInfo.name,
                userID: urlInfo._id,
                suborg: urlInfo.suborg,
                shortURLEndPoint: shortURLEndPoint,
                originalURL: urlInfo.originalURL,
            });
        let newURLData = await newURL.save();
        if(!newURLData)
            return next(new AppError("Failed to create. Please try again", 500));
        return newURLData;
    }
    catch(err){
        next(err);
    }
};

//Create a new short URL for suborg
const createNewSuborgURL = async (urlInfo, next) => {
    try{
        //throw error
        let isValid = await dnsCheck(urlInfo.originalURL);
        if(!isValid){
            return next(new AppError("Original URL doesn't exist", 400));
        }
        if(!urlInfo.originalURL.startsWith('https://') && !urlInfo.originalURL.startsWith('http://'))
            urlInfo.originalURL = 'https://'+urlInfo.originalURL;

        let shortURLEndPoint;
        if(urlInfo.wishCustom){
            shortURLEndPoint = urlInfo.suborg + '/' + urlInfo.customURL;
        }
        else{
            shortURLEndPoint = await generateEndpoint();
            shortURLEndPoint = urlInfo.suborg + '/' + shortURLEndPoint;
        }

        let urlCount = await URL.count({ shortURLEndPoint: shortURLEndPoint});
        if(urlCount > 0)
            return next(new AppError("This custom URL already exists.", 400));


        let newURL = new URL(
            {
                email: urlInfo.email,
                name: urlInfo.name,
                userID: urlInfo._id,
                suborg: urlInfo.suborg,
                shortURLEndPoint: shortURLEndPoint,
                originalURL: urlInfo.originalURL,
            });
        let newURLData = await newURL.save();
        if(!newURLData)
            return next(new AppError("Failed to create. Please try again", 500));
        return newURLData;
    }
    catch(err){
        next(err);
    }
};

module.exports = {
    getAllURLs,
    getURLsByUser,
    blacklistURL,
    whitelistURL,
    deleteURL,
    getRedirectURL,
    incrementURLHits,
    updateSuborgURL,
    createNewShortURL,
    createNewSuborgURL
};
